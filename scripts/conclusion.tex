\cchapter{نتیجه‌گیری}
\label{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ایده و محدوده کار آینده %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ایده و محدوده‌ی کاری در آینده}

با مطالعه در ادبیات موضوع\ref{literature} و کارهای انجام\ref{related-works}  شده فهمیدیم که مشکل شروع سرد مشکل گسترده‌ای است و محدود به حوزه‌ی خاصی نمی‌شود. همانگونه که مطرح شد عواملی مثل حجم حافظه مصرفی تابع، سربار تابع، نوع کانفیگ سرور، مشخصات سخت‌افزاری سرور زیرساخت، وضعیت شبکه، زبان برنامه‌نویسی‌ای که تابع با آن نوشته شده و ... در تاخیر شروع سرد بسیار موثر و تاثیرگذار هستند. البته در این گزارش از بی روش‌های کنترل شروع سرد بر روی ویژگی‌های شبکه برای کاهش مدت زمان آماده‌سازی و روش‌های پیشگیری از شروع سرد توقف کردیم. متاسفانه مدت زمان کافی برای مطالعه سایر روش‌ها فراهم نشد. 

روش‌های پیشگیری از شروع سرد، اگر چه در سناریوی موفق خود باعث به صفر رسیدن تاخیر شروع سرد می‌شوند، اما در سناریوهای ناموفق خود تاخیر شروع سرد به طور عادی برای تابع اتفاق می‌افتد. نکته‌ی منفی درمورد اکثر این روش‌های این است که علاوه‌بر دقت پایین یا خطا‌های بسیار برای شناسایی الگوی شروه سرد، - که کار بسیار دشواری هم هست، - این روش‌ها سربار محاسباتی بسیار بالایی برای پیش‌بینی دارند درحالی‌که وقت ما برای پیش بینی بسیار محدود است. از طرف دیگر، پیچیدگی اجرا و مدت‌زمان سربار محاسباتی برای روش‌های مبتنی بر کاهش زمان شروع سرد بسیار کمتر است. شاید به همین دلیل است که بیشتر در صنعت و پژوهش‌های عملی مورد استقبال قرار گرفته اند. از طرفی هم این روش ها مانع از تاخیر شروع سرد نمی‌شوند و نمی‌توانند به طور کامل جایگزین روش پیشگیری از شروع سرد شوند. 

به نظر می‌رسد ترکیب این دو روش به عنوان کار آینده گزینه جذابی باشد. مثلا از راهکار‌هایی برای فرار از شروع سرد استفاده کرد. در کنار این قضیه، از راهکارهایی نیز برای جلوگیری از شروع سرد استفاده کنیم. در بهترین حالت، علاوه بر اینکه زمان پاسخ را کم کرده‌ایم توانسته ایم با دقت خوبی هم از به وقوع پیوستن شروع سرد نیز جلوگیری کنیم. اما از طرفی ممکن است باعث بیش‌مهندسی\LTRfootnote{Over Engineering} شدن قضیه بشویم. این موضوع نیازمند بررسی بیشتر است و نیاز به تحقیق بیشتری برای قطعی شدن موضوع داریم. 

در قدم پیشرفته‌تر می‌توان از این کار برای به حداقل رسانی شروع سرد در ترکیبات توابع استفاده کرد. این موضوع برای به حداقل رسانی توابعی که در Orchestrator ترکیب شده‌اند بسیار مفید می‌تواند باشد. فرض کنید ۲ تابع داریم که با الگوی زنجیره‌ای\LTRfootnote{Chaining} به هم وصل شده‌اند. پس با فراخوانی تابع اول می‌دانیم تابع دوم هم حتما فراخوانی می‌شود. پس باید قبل از فراخوانی، تابع گرم شود. برای این کار پژوهش‌های انجام شده در \cite{mohan2019agile, lin2019mitigating} می‌تواند بسیار کمک کننده باشد. 

اگر قرار به استفاده از دیتاستی باشد تنها دیتاست در دسترس در \cite{AzurePublicDataset} وجود دارد که اطلاعات مصرف و فراخوانی توابع در سال‌های 2019 و 2020 را به صورت متن‌باز منتشر کرده‌است. برای این کار مجبور هستیم اقدام به پیاده‌سازی پلتفرم مد نظر خود کنیم. برای این کار احتمالا مجبور شویم کدپروژه پلتفرمی را که می‌خواهیم تغییر دهیم را برای سازگاری با سیاست‌های خودمان تغییر دهیم. نتیجه این تغییرات پلتفرم جدیدی بر مبنای پلتفرم پایه خواهد بود که آن را در آینده ارائه خواهیم داد. 










%%%%%%%%%%%%%%%%%%% نتیجه گیری کلی %%%%%%%%%%%%%%%%%%%%%%%%%%
\section{نتیجه‌گیری کلی}

در \autoref{intro} به بیان مقدمه‌ای از موضوع و در \autoref{literature} به بیان ادبیات موضوع پرداختیم تا خواننده را با موضوعاتی که قرار است در پژوهش در باره آن بحث کنیم آشنا سازیم. پس از آشنایی با مباحث پایه‌ای به بیان کارهای انجام شده و ایده‌هایی که تاکنون در این حوزه مطرح شده است، در \autoref{related-works} پرداختیم. 

به طور خلاصه برای مدیریت شروع سرد دو سیاست کلی می‌توان داشت. سیاست اول این است که زمان آماده‌سازی برنامه را کم کنیم تا مدت زمان تاخیر به حداقل برسد. یعنی در واقع، ما اجازه وقوع شروع سرد را به تابع می‌دهیم ولی مدت‌ زمان ناشی از تغییر را حداقل کرده‌ایم. سیاست دوم این است که مانع وقوع شروع سرد بشویم. هر دو سیاست از موضوعات ترند و پرپژوهش در این حوزه هستند. 

همانگونه که می‌دانید روش پایه‌ای برای مدیریت شروع سرد، روش زمان ثابت زنده ماندن توابع\LTRfootnote{Fixed-Time alive} است. در این روش، تابع تا مدت زمان ثابتی پس از آخرین فراخوانی گرم می‌ماند و اگر در آن بازه صدا زده نشود سرد می‌شد. این روش بسیر ابتدایی است و هرگز نمی‌توانست الگو‌های فراخوانی را تشخصی دهد و در فراخوانی‌های متناوب در بازه‌های طولانی‌تر از بازه \lr{Keep Alive}، همواره شروع سرد را تجربه می‌کردیم. اگرچه در مصرف منابع هم به نسبت بازدهی خوبی نداریم. بنابراین این روش در مقایسه با روش‌هایی که به دنبال مدل‌سازی برای گرم کردن تابع هستند نه بازدهی خوبی از نظر منابع دارد و نه توانسته است از نظر مدت‌زمان پاسخ\LTRfootnote{Response Time} پاسخ خوبی داشته باشد. 

از طرفی روش‌های بهینه‌سازی سرور وجود دارند که اگرچه مدت زمان پاسخ با درنظر گرفتن شروع سرد را کاهش می‌دهند اما خود باید مراقب سربارهای احتمالی مانند سایز حافظه کش، سایز استخر گرم و ... باشند تا بتوان گفت از نظر مصرف منابع بسیار بهینه عمل می‌کنند. این روش‌ّا اگر چه مدت زمان را کم می‌کند اما همچنان از تاخیر شروع سرد رنج می‌بریم. همچنین مدت‌زمانی که زمان پاسخ برمی‌گردد آن‌قدر کاهش نمی‌یابد که بگوییم مشکل زمان پاسخ حل شده است.

حال ایده‌ای که مطرح می‌شود این است که آیا با ترکیب این روش‌ها می‌توان به روش‌ بهینه‌ای برای مدیریت شروع‌های سرد رسید یا خیر؟‌ این سوال اصلی این پژوهش است و برای پاسخ به آن به مطالعه‌ی خیلی بیشتری نیاز است. اما اگر بتوانیم با استفاده از مدل پیشگیری مناسب مانع اتقاق افتادن شروع‌های سرد شویم و از ظرف دیگر با استفاده از یک تکنیک بهینه مدت زمان لود شدن تابع را حتی در صورت اتفاق افتادن شروع سرد کاهش بدهیم مسئله را با دقت بسیار خوبی حل کرده ایم.

البته باید توجه داشت این یک کار بسیار چالش برانگیز است. در \cite{gias2020cocoa} ماباید برای هر تابع بتوانیم زنجیره مارکوف آن را رسم کرده و با ترکیب با LQN به پیش‌بینی بهینه بر اساس توافقات سطح سرویس شویم. اینکار بسیار طولانی و چالشی است؛‌اگرچه که دقت خوبی دارد و به خوبی توانسته است سطح انتظارات را برآورده سازد. یا مثلا در \cite{shahrad2020serverless} ممکن است حتی مسئله را اصطلاحا بیش‌ مهندسی کرده باشیم. 

ما همواره در مهندسی نرم‌افزار و شبکه به دنبال کم کردن تاخیر ناشی از ارتباطات در شبکه و سرور با کاربران هسنیم. پس می‌توان گفت تا کنون به مبحث شروع سرد بسیار بی‌توجهی شده است. موضوع دیگری که در این بیین بسیار مغوف مانده است، امکان کاهش شروع سرد برای رکیبات توابع است که پاسخی برای این موضوع مشاهده نشده است. 





